# Урок 4. Семинар: Объектно-ориентированные паттерны

## Задание 1. Закончить разработку паттерна "Фабричный метод"

### **Паттерн "Фабричный метод" (Factory Method)**

**Описание:**

Паттерн "Фабричный метод" является порождающим паттерном проектирования, который предоставляет интерфейс для создания объектов некоторого класса, но позволяет подклассам решать, какой класс инстанцировать. То есть, он делегирует создание объектов потомкам, позволяя классам откладывать инстанцирование до момента создания подкласса.

**Когда применять:**

- Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код.
- Когда система должна быть независимой от процесса создания, компоновки и представления продуктов.
- Когда в систему должны вводиться новые продукты без изменения существующего кода.

### **Шаги разработки паттерна "Фабричный метод":**

1. **Определение интерфейса продукта:**

   Создайте интерфейс или абстрактный класс, который определяет методы, общие для всех продуктов, которые будут создаваться фабрикой.

2. **Реализация конкретных продуктов:**

   Создайте классы, реализующие этот интерфейс. Каждый класс представляет конкретный продукт.

3. **Создание абстрактной фабрики:**

   Создайте абстрактный класс-фабрику, который содержит абстрактный метод фабрики для создания продуктов.

4. **Реализация конкретных фабрик:**

   Создайте подклассы фабрики, которые переопределяют метод фабрики для создания конкретных продуктов.

### **Пример реализации на языке C#**

**Шаг 1: Определение интерфейса продукта**

```csharp
// Интерфейс продукта
public interface ITransport
{
    void Deliver();
}
```

**Шаг 2: Реализация конкретных продуктов**

```csharp
// Конкретный продукт: Грузовик
public class Truck : ITransport
{
    public void Deliver()
    {
        Console.WriteLine("Доставка грузом на грузовике по дороге.");
    }
}

// Конкретный продукт: Корабль
public class Ship : ITransport
{
    public void Deliver()
    {
        Console.WriteLine("Доставка грузом на корабле по морю.");
    }
}
```

**Шаг 3: Создание абстрактной фабрики**

```csharp
// Абстрактная фабрика
public abstract class Logistics
{
    // Фабричный метод
    public abstract ITransport CreateTransport();

    public void PlanDelivery()
    {
        // Создаем транспорт
        var transport = CreateTransport();
        // Используем его
        transport.Deliver();
    }
}
```

**Шаг 4: Реализация конкретных фабрик**

```csharp
// Конкретная фабрика: Дорожная логистика
public class RoadLogistics : Logistics
{
    public override ITransport CreateTransport()
    {
        return new Truck();
    }
}

// Конкретная фабрика: Морская логистика
public class SeaLogistics : Logistics
{
    public override ITransport CreateTransport()
    {
        return new Ship();
    }
}
```

**Шаг 5: Использование фабричного метода**

```csharp
class Program
{
    static void Main(string[] args)
    {
        Logistics logistics;

        // Допустим, нам нужно доставить груз по морю
        logistics = new SeaLogistics();
        logistics.PlanDelivery();

        // Теперь нужно доставить груз по дороге
        logistics = new RoadLogistics();
        logistics.PlanDelivery();

        Console.ReadLine();
    }
}
```

**Вывод программы:**

```
Доставка грузом на корабле по морю.
Доставка грузом на грузовике по дороге.
```

### **Объяснение:**

- **Интерфейс `ITransport`** определяет метод `Deliver`, который должен быть реализован всеми конкретными транспортными средствами.
- **Классы `Truck` и `Ship`** — конкретные продукты, реализующие интерфейс `ITransport`.
- **Абстрактный класс `Logistics`** содержит фабричный метод `CreateTransport`, который возвращает объект типа `ITransport`. Также в нем есть метод `PlanDelivery`, который использует созданный транспорт.
- **Классы `RoadLogistics` и `SeaLogistics`** — конкретные фабрики, которые переопределяют метод `CreateTransport` для создания конкретных продуктов.
- **В методе `Main`** мы можем динамически выбирать, какой логистикой пользоваться, и создавать соответствующие транспортные средства.

### **Преимущества использования фабричного метода:**

- **Изоляция кода создания объектов от кода их использования.**
- **Упрощение добавления новых продуктов.** Можно просто создать новый класс продукта и соответствующую фабрику.
- **Улучшение поддерживаемости кода.**
